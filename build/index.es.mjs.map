{"version":3,"file":"index.es.mjs","mappings":"mBAsCO,SAASA,EAASC,GACvB,MAAsB,iBAARA,EAST,SAASC,EAAUD,GACxB,MAAsB,kBAARA,EAOT,IAAME,EAAW,IAAIC,IAC5BD,EAASE,IAAI,SAjDN,SAAiBJ,GACtB,OAAOK,MAAMC,QAAQN,MAiDvBE,EAASE,IAAI,UA9BN,SAAkBJ,GACvB,MAAsB,iBAARA,KA8BhBE,EAASE,IAAI,SAAUL,GACvBG,EAASE,IAAI,UA1CN,SAAkBJ,GACvB,OAAOA,aAAeO,UA0CxBL,EAASE,IAAI,UAAWH,GACxBC,EAASE,IAAI,eAAgBL,G,ICtBxBS,GAAL,SAAKA,GACH,cACA,YACA,YACA,sBACA,gBALF,CAAKA,IAAAA,EAAW,M","sources":["webpack://@amateury/lettuce/./src/help.ts","webpack://@amateury/lettuce/./src/parser.ts"],"sourcesContent":["export type TIsValidate = (elm: any) => boolean;\n\n/**\n * validate if it is an array\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isArray(elm: any): boolean {\n  return Array.isArray(elm);\n}\n\n/**\n * validate if it is an objet\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isObject(elm: any): boolean {\n  return elm instanceof Object;\n}\n\n/**\n * validate if it is an string\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isString(elm: any): boolean {\n  return typeof elm === \"string\";\n}\n\n/**\n * validate if it is a number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isNumber(elm: any): boolean {\n  return typeof elm === \"number\";\n}\n\n/**\n * validate if it is a number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isBoolean(elm: any): boolean {\n  return typeof elm === \"boolean\";\n}\n\n/**\n * Functions validations (isArray, isString)\n *\n */\nexport const validate = new Map<string, TIsValidate>();\nvalidate.set(\"Array\", isArray);\nvalidate.set(\"String\", isString);\nvalidate.set(\"Number\", isNumber);\nvalidate.set(\"Object\", isObject);\nvalidate.set(\"Boolean\", isBoolean);\nvalidate.set(\"MyNumberType\", isNumber);\n","import { validate, isBoolean } from \"./help\";\nimport { capitalizeWord, trip } from \"./util\";\n\ntype TTarget = string | number;\ntype TRegex = RegExp;\ntype TType = any | any[];\n\nexport interface IScheme {\n  target: TTarget;\n  type: TType;\n  required?: boolean;\n  min?: number;\n  max?: number;\n  value?: ((value: any) => any) | any;\n  strict?: boolean;\n  regex?: TRegex;\n  message?: any;\n}\n\nexport type TValue = any;\n\n/**\n * Values\n */\nexport type TValues = {\n  [index: TTarget]: TValue;\n};\n\nexport type TStrictCycle = boolean | number;\n\n/**\n * Config\n */\nexport type TConfig =\n  | {\n      strictCycle?: TStrictCycle;\n    }\n  | null\n  | undefined;\n\nenum TypesErrors {\n  type = \"type\",\n  min = \"min\",\n  max = \"max\",\n  required = \"required\",\n  regex = \"regex\",\n}\n\nexport type TErrorVal = string;\n\nexport type TErrors = {\n  error: TErrorVal[];\n  target: TTarget;\n  value: any | any[];\n};\n\n/**\n * Run a bug\n * @param e - Error\n */\nconst error = (e: any) => {\n  throw e;\n};\n\n/**\n * Generate new Error\n * @param e - Error\n */\nconst newError = (e: any) => {\n  error(new Error(e));\n};\n\n/**\n * Validate is required\n * @param required - Value required (boolean)\n * @param val - Value of validation\n */\nconst isRequired = async (\n  required: boolean | undefined,\n  val: TValue\n): Promise<void> => {\n  if (required && !val && !isBoolean(val)) error(TypesErrors.required);\n};\n\n/**\n * In this function, the custom data type is validated through\n * the static method __validate__.\n * @param val - Value of validation\n * @param type - Data type\n */\nconst customValidateValue = async (val: TValue, type: TType) => {\n  try {\n    const valid = await type.__validate__(val);\n    /* istanbul ignore else */\n    if (!valid) {\n      error(TypesErrors.type);\n    }\n  } catch (e) {\n    if (e === TypesErrors.type) error(e);\n    newError(`No validation custom format found: ${e}`);\n  }\n};\n/**\n * Validate data type\n * @param scheme - Type to validation\n * @param val - Value of validation\n * @param type - Data type\n */\nconst validateValueType = async (\n  scheme: IScheme,\n  val: TValue,\n  type: TType\n): Promise<TValue> => {\n  // It is a boolean to know if the data will be strictly validated\n  if (scheme.strict) {\n    const validateStrict = validate.get(type.name);\n    if (validateStrict) {\n      if (!validateStrict(val)) error(TypesErrors.type);\n    } else {\n      await customValidateValue(val, type);\n    }\n  }\n\n  let formatVal: TValue = val;\n  if (type.name === \"Array\") {\n    formatVal = val ? type.from(val) : val;\n  } else if (Object.prototype.hasOwnProperty.call(type, \"__validate__\")) {\n    await customValidateValue(val, type);\n  } else {\n    formatVal = val ? type(val) : val;\n  }\n\n  return formatVal;\n};\n\n/**\n * Validate data type\n * @param scheme - Type to validation\n * @param val - Value of validation\n * @param type - Data type\n */\nconst valuePick = async (scheme: IScheme, val: TValue, type: TType) => {\n  type TTripArg = { value: TValue; len: number };\n  if (!type.length && type.length !== undefined) error(TypesErrors.type);\n  return await trip(type, async ({ value, len }: TTripArg) => {\n    if (value instanceof Function) {\n      try {\n        return await validateValueType(scheme, val, value);\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n    } else {\n      if (val === value) return val;\n      else if (typeof value === \"object\" && value) {\n        const resultValid = await trip(value, ({ value: v }) => v === val);\n        /* istanbul ignore else */\n        if (resultValid) return val;\n      }\n    }\n    if (len === 1) error(TypesErrors.type);\n  });\n};\n\n/**\n * Formats the target value to the specified type\n * @param scheme - Type to validation\n * @param val - Value of validation\n */\nconst valueType = async (scheme: IScheme, val: TValue): Promise<TValue> => {\n  const type = scheme.type; // Type to validation\n  return await (typeof type === \"object\"\n    ? valuePick(scheme, val, type)\n    : validateValueType(scheme, val, type));\n};\n\n/**\n * Evaluate minimum value\n * @param val - Value of validation\n * @param min - Value of minimum (number)\n * @param typeName - Name function type\n */\nconst min = async (val: TValue, min: number, typeName: string) => {\n  let validMin = null;\n  const _typeName = capitalizeWord(typeName);\n  if (val.length) {\n    validMin = val.length >= min;\n  } else if (_typeName === \"Number\" || _typeName === \"BigInt\") {\n    validMin = val >= min;\n  }\n  if ((validMin !== null && !validMin) || !validMin) error(TypesErrors.min);\n  return validMin;\n};\n\n/**\n * Evaluate maximum value\n * @param val - Value of validation\n * @param max - Value of maximum (number)\n * @param typeName - Name function type\n */\nconst max = async (val: TValue, max: number, typeName: string) => {\n  let validMin = null;\n  const _typeName = capitalizeWord(typeName);\n  if (val.length) {\n    validMin = val.length <= max;\n  } else if (_typeName === \"Number\" || _typeName === \"BigInt\") {\n    validMin = val <= max;\n  }\n  if ((validMin !== null && !validMin) || !validMin) error(TypesErrors.max);\n  return validMin;\n};\n\nconst regexValid = async (val: TValue, reg: TRegex) => {\n  if (!reg.test(val)) error(TypesErrors.regex);\n};\n\n/**\n * Extra validation: minimum value, maximum value, regex\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n * @param typeName - Name function type\n * @param callBack -\n */\nasync function extraValidation(\n  scheme: IScheme,\n  val: TValue,\n  typeName: string,\n  callBack: any\n): Promise<TValue> {\n  const valIsValid = scheme.required\n    ? scheme.required\n    : !(!val && !scheme.required);\n  if (scheme.min && valIsValid)\n    await min(val, scheme.min, typeName).catch(callBack);\n  if (scheme.max && valIsValid)\n    await max(val, scheme.max, typeName).catch(callBack);\n  if (scheme.regex && valIsValid)\n    await regexValid(val, scheme.regex).catch(callBack);\n\n  return val;\n}\n\n/**\n * Add the default value, set the value property, the value property can be a\n * function and will be interpreted as a callback\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n */\nconst valueDefault = async (scheme: IScheme, val: TValue): Promise<TValue> => {\n  if (scheme.value && scheme.value instanceof Function)\n    return await scheme.value(val);\n  return scheme.value !== undefined && !val ? scheme.value : val;\n};\n\ntype TRValidScheme = [TValue, TErrorVal[]];\n\n/**\n * Function that validates the value against the schema data\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n */\nasync function validScheme(\n  scheme: IScheme,\n  val: TValue\n): Promise<TRValidScheme> {\n  const errors: TErrorVal[] = [];\n  const pushError = (e: any) => {\n    if (e in TypesErrors) {\n      errors.push(e);\n    } else {\n      error(e);\n    }\n  };\n\n  await isRequired(scheme.required, val).catch(pushError);\n  const formatVal = await valueType(scheme, val).catch(pushError);\n\n  if (errors.length) return [formatVal, errors];\n\n  const typeName = typeof formatVal;\n  const respVal = await extraValidation(scheme, formatVal, typeName, pushError);\n  return [respVal, errors];\n}\n\ntype TResolution = (value: [TTarget, TValue]) => void;\ntype TCallBackErr = (value: TErrors, index: number) => void;\n\n/**\n * Function that serves as a bridge between validScheme and parserScheme\n * @param resolution - callback that sets the resolved values\n * @param callBackErr - callback that sets the values with error\n * @param scheme - Scheme\n * @param val - Value of validation\n * @param index - Counting rate\n */\nasync function runValidation(\n  resolution: TResolution,\n  callBackErr: TCallBackErr,\n  scheme: IScheme,\n  val: any,\n  index: number\n) {\n  await validScheme(scheme, val).then(([value, errors]) => {\n    if (!errors.length) {\n      resolution([scheme.target, value]);\n    } else {\n      const er = {\n        error: errors,\n        target: scheme.target,\n        value: val,\n      };\n      callBackErr(er, index);\n    }\n  });\n}\n\n/**\n * Assign default values to a schema\n * @param scheme - Schemes\n */\nconst defaultScheme = (scheme: IScheme) => ({\n  required: true,\n  strict: true,\n  ...scheme,\n});\n\n/**\n * Analyze the values provided according to your schema.\n * @param schemes - Schemes\n * @example\n * Example of a schematic:\n *```json\n *[\n *  { target: \"email\", type: String, required: true, strict: true},\n *  { target: \"name\", type: String, required: true, strict: true, min: 8, max: 80},\n *  { target: \"password\", type: String, required: true, strict: true, min: 8},\n *]\n *```\n * @param values - Data to validate\n * @example\n * Example of a data to validate:\n * ```json\n * {\n *   email: \"lettuce@lettuce.com\",\n *   name: \"Lettuce\",\n *   password: \"sW6LT#Fh\",\n * }\n * ```\n * @param config - Config\n */\nexport async function parserScheme(\n  schemes: IScheme[],\n  values: TValues = {},\n  config: TConfig\n) {\n  type TFun = {\n    _values: TValues;\n    values: TValues;\n    _errors: TErrors[];\n    resolution: TResolution;\n    callBackErr: TCallBackErr;\n  };\n\n  const fun: TFun = {\n    _values: {},\n    _errors: [],\n    get values(): TValues {\n      return this._values;\n    },\n    resolution([target, val]: [TTarget, TValue]): void {\n      if (val !== undefined)\n        Object.defineProperty(fun._values, target, {\n          enumerable: true,\n          value: val,\n        });\n    },\n    callBackErr(value: TErrors, index: number) {\n      fun._errors.push(value);\n      if (\n        (config &&\n          config.strictCycle &&\n          typeof config.strictCycle === \"boolean\") ||\n        (config && config.strictCycle === index + 1)\n      ) {\n        error(fun._errors);\n      }\n    },\n  };\n\n  await trip(schemes, async ({ value, index }) => {\n    const scheme = defaultScheme(value);\n    const val = await valueDefault(scheme, values[scheme.target]);\n    await runValidation(fun.resolution, fun.callBackErr, scheme, val, index);\n  });\n\n  return fun._errors.length ? error(fun._errors) : fun.values;\n}\n"],"names":["isNumber","elm","isBoolean","validate","Map","set","Array","isArray","Object","TypesErrors"],"sourceRoot":""}