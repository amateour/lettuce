{"version":3,"file":"index.es.mjs","mappings":"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","sources":["webpack://@amateour/lettuce/webpack/bootstrap","webpack://@amateour/lettuce/webpack/runtime/global","webpack://@amateour/lettuce/./src/help.ts","webpack://@amateour/lettuce/./src/verifyErrors.ts","webpack://@amateour/lettuce/./src/argument.ts","webpack://@amateour/lettuce/./src/type.ts","webpack://@amateour/lettuce/./src/lettuce.ts","webpack://@amateour/lettuce/./src/parserLettuce.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","import * as SW from '../functions/help';\n\n/**\n * Identify if it is running in a browser\n */\nexport const isBrowser: () => boolean = () => typeof window !== 'undefined'\n    && ({}).toString.call(window) === '[object Window]';\n\n/**\n * Identify if it is running in a nodejs\n */\nexport const isNode: () => boolean = () => typeof global !== \"undefined\"\n    && ({}).toString.call(global) === '[object global]';\n\n/**\n * validate if it is an array\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isArray(elm: any): boolean {\n    return Array.isArray(elm);\n}\n\n/**\n * validate if it is an objet\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isObject(elm: any): boolean {\n    return elm instanceof Object;\n}\n\n/**\n * validate if it is an string\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isString(elm: any): boolean {\n    return typeof elm === \"string\";\n}\n\n/**\n * validate if it is an number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isNumber(elm: any): boolean {\n    return typeof elm === \"number\";\n}\n\n/**\n * Functions validations (isArray, isString)\n *\n */\nexport const validate = new Map<string, SW.isValid>();\nvalidate.set('Array', isArray);\nvalidate.set('String', isString);\nvalidate.set('Number', isNumber);\nvalidate.set('Object', isObject);\nvalidate.set('Browser', isBrowser);\nvalidate.set('Browser', isNode);\n\n","import {ResponseVerifyErrors, ErrorStatus} from \"../functions/verifyErrors\";\n\n/**\n * Generate exception\n * \n * @param response - data response\n */\nfunction error(response: ResponseVerifyErrors): ResponseVerifyErrors {\n    throw response;\n}\n\n/**\n * Raise exception for errors handled from a server\n * \n * @param response - data response\n * @param code - status code\n */\nfunction responseServerError(response: ResponseVerifyErrors, code: number): ResponseVerifyErrors {\n    const {message, errors} = response;\n    throw {\"statusCode\": code, \"message\": message, errors};\n}\n\n/**\n * Throw exception, the response returns the key status code depending on the ecosystem where the deployment is running\n * \n * @param response - data response\n * @param code - status code\n */\nexport function exception(response: ResponseVerifyErrors, code: number) {\n    typeof window !== 'undefined'\n    && ({}).toString.call(window) === '[object Window]'\n        ? error(response) : responseServerError(response, code);\n}\n\n/**\n * validate errors and send message\n *\n * @param errors - Array data errors\n */\nexport async function verifyErrors(\n    errors: ErrorStatus[]\n): Promise<ResponseVerifyErrors | any> {\n\n    const response: ResponseVerifyErrors = {\n        errors: [],\n        message: 'args_validation_successful'\n    }\n\n    if (errors.length) {\n        response.errors = errors;\n        response.message = 'args_validation_errors';\n        exception(response, 400);\n    } else {\n        return response\n    }\n}\n","import * as AR from '../functions/arguments';\nimport * as VA from '../functions/validator';\nimport * as VE from '../functions/verifyErrors';\nimport {validate} from \"./help\";\nimport {exception} from './verifyErrors'\n\n/**\n *\n * Response messages due to validation failure\n */\nconst messageArgument: AR.MessageArgument = {\n    validation: () => ({\n        message: `validation_custom`\n    }),\n    required: () => ({\n        message: \"required_field\"\n    }),\n    min: (props) => ({\n        message: \"minimum_characters\",\n        value: props.validValue\n    }),\n    max: (props) => ({\n        message: \"maximum_characters\",\n        value: props.validValue\n    }),\n    strict: (props) => ({\n        message: \"{key}_expected_data_type_{type}\"\n            .replace('{key}', props.key)\n            .replace('{type}', props.type)\n            .toLowerCase()\n    })\n}\n\n/**\n * Extract validation error message\n * \n * @param key - validation key name\n * @param props - values for error interpretation\n * @returns - Json\n * \n * @example \n * Example of validation error of the minimum data required (min)\n * \n * ```json\n * {\n        message: \"minimum_characters\",\n        value: 8\n    }\n * ```\n */\nfunction ejectMessage(key: string, props: any): AR.MessageArgumentResponse | string {\n\n    if (props.message && key) {\n        if (typeof props.message == 'string') return props.message;\n        if (props.message[key]) return props.message;\n    }\n\n    switch (key) {\n        case 'validation': return messageArgument.validation();\n        case 'required': return messageArgument.required();\n        case 'min': return messageArgument.min(props);\n        case 'max': return messageArgument.max(props);\n        case 'strict': return messageArgument.strict(props);\n        default:\n            throw 'non-specific validation function: undefined response message'\n    }\n}\n\n/**\n *  list of validation functions\n *\n */\nconst funcArguments: AR.funcArguments = {\n\n    /**\n     *  * custom validation, for the data type specified in the argument\n     *\n     * @example\n     * ```json\n     * {\n     *    email: {\n     *    type: Sandwich.String, validation: (value: string) => typeof value == 'string'\n     *  }\n     * }\n     * ```\n     * @param validValue - validation function\n     * @param value - value to validate\n     */\n    validation: ({validValue, value}) => validValue(value),\n\n    /**\n     * Validate value max\n     *\n     * @param validValue - comparison value for validation\n     * @param value - value to validate\n     */\n    max: ({validValue, value}) => {\n        if (typeof value === 'number'){\n            return (value ?? 0) <= (validValue ?? 0);\n        } else {\n            const len = (value?.length ?? 0) ?? (value?.toString()?.length ?? 0);\n            return len <= (validValue ?? 0);\n        }\n\n    },\n\n    /**\n     * Validate value min\n     *\n     * @param validValue - comparison value for validation\n     * @param value - value to validate\n     */\n    min: ({validValue, value}) => {\n        if (typeof value === 'number'){\n            return (validValue ?? 0) >= (validValue ?? 0);\n        } else {\n            const len = (value?.length ?? 0) ?? (value?.toString()?.length ?? 0);\n            return len >= (validValue ?? 0);\n        }\n    },\n\n    /**\n     * validate value required\n     *\n     * @param validValue - comparison value for validation\n     * @param value - value to validate\n     */\n    required: ({validValue, value}) => validValue ? (!!value || value === 0) : true,\n\n    /**\n     * Validate value type\n     *\n     * @param value - value to validate\n     * @param func - Objeto primitivo correspondiente al tipo de dato declarado para validación\n     * @param scheme - scheme data\n     */\n     type: (value, func, scheme) => {\n        const list_type = ['String', 'Number', 'Object'];\n\n        switch (func.name) {\n            case 'Array': return func.from(value);\n            default:\n                if (list_type.includes(func.name)){\n                    return new func(value)\n                }\n                return func(value, scheme);\n        }\n    },\n\n    /**\n     * Strictly validates the value of a data type\n     *\n     * @param strict - true to validate or false not to validate strict mode\n     * @param type - Array\n     * @param key - data (occupation)\n     * @param value - `Developer`\n     */\n    validStrict: (strict, type, key, value) => {\n        const valid = validate.get(type);\n\n        if (strict && valid) {\n            !valid(value) ? exception({\n                message: \"args_validation_errors\",\n                errors: [{\n                    [key]: [messageArgument.strict({key, type})]\n                }]\n            }, 400): true\n        }\n    }\n}\n\n/**\n * Validar argumentos según su key de validación\n *\n * @param key - 'required'\n * @param props - schema data\n */\nfunction validArguments(key: string, props: any): boolean {\n    switch (key) {\n        case 'required': return funcArguments.required(props);\n        case 'min': return funcArguments.min(props);\n        case 'max': return funcArguments.max(props);\n        case 'validation': return funcArguments.validation(props);\n        default:\n            throw 'non-specific validation function'\n    }\n}\n\n/**\n * Validate a data type\n *\n * @param value - value to validate \"Developer\"\n * @param key - value key (occupation)\n * @param scheme - scheme validation\n * ```json\n * {type: String}\n * ```\n */\nasync function validType ({value, key, scheme}: AR.compareProps): Promise<any> {\n    const type: any = scheme['type'];\n    const strict = scheme['strict'];\n    const required = scheme['required'];\n\n    if (type) {\n        const name = type.name;\n        required && value ? funcArguments.validStrict(strict, name, key, value): null;\n        if (value === null || value === undefined) return value;\n        return funcArguments.type(value, type, scheme);\n    } else {\n        exception({message: `${key} => ${value} no data type`}, 500);\n    }\n}\n\n/**\n * Validate a schema against a value\n *\n * @param props - data\n * @param type - data type to validate example String\n * @param validValue - value of validation\n * @param keyValid - key main\n */\nfunction validData(\n    props: AR.compareProps, type: any, validValue: any, keyValid: keyof AR.MessageArgument\n): Promise<AR.MessageArgumentResponse | boolean> {\n    return new Promise((resolve) => {\n\n        const {value, scheme, message, key: keyMain} = props;\n\n        if(!validArguments(keyValid, {validValue, value, type, scheme})) {\n            resolve(ejectMessage(keyValid, {validValue, value, type, keyValid, keyMain, message}));\n        }\n\n        resolve(false);\n    })\n}\n\n/**\n * Validate a schema against a value\n *\n * @param props - data\n * @param type - data type to validate example String\n */\nasync function validExtractArgument (\n    props: AR.compareProps, type: any\n): Promise<(AR.MessageArgumentResponse | boolean)[]> {\n    const validResponse = [];\n    const {scheme} = props;\n\n    /**\n     *\n     */\n    if(scheme['required']) {\n        const resp = await validData(props, type, scheme['required'], 'required')\n        if(resp) validResponse.push(resp);\n    }\n\n    /**\n     *\n     */\n    if(scheme['min']){\n        const resp = await validData(props, type, scheme['min'], 'min');\n        if(resp) validResponse.push(resp);\n    }\n\n    /**\n     *\n     */\n    if(scheme['max']) {\n        const resp = await validData(props, type, scheme['max'], 'max');\n        if(resp) validResponse.push(resp);\n    }\n\n    /**\n     *\n     */\n    if(scheme['validation']) {\n        const resp =await validData(props, type, scheme['validation'], 'validation')\n        if(resp) validResponse.push(resp)\n    }\n\n    return validResponse;\n}\n\n/**\n * validate Message\n *\n * @param errors -\n */\nasync function validRespArgument (errors: (AR.MessageArgumentResponse | boolean)[]): Promise<boolean> {\n    return !errors.length;\n}\n\n/**\n * Validate an argument schema\n *\n * @param props - data\n *\n * @example\n * ```json\n * {\n *     value: \"example@sandwich.com\"\n *     key: \"email\"\n *     scheme: {type: Sandwich.String, strict: true}\n * }\n * ```\n */\nasync function validArgument (props: AR.compareProps): Promise<AR.validArgumentResp> {\n\n    const type =  await validType(props);\n    const errors = await validExtractArgument(props, type);\n    const success = await validRespArgument(errors);\n\n    return {errors: errors, success, value: type}\n}\n\n/**\n * Extract the defined value from the req or in the schema\n * (any value passed by req will be replaced by the value is defined in the schema)\n *\n * @param reqBody - data body\n * @param scheme -\n * @param key - field key to validate\n */\nfunction getValue(reqBody: { [index: string | number]: any }, scheme: VA.scheme, key: string | number): any {\n    const definedValue = scheme['value'] ?? reqBody[key];\n    return definedValue instanceof Function ? definedValue() : definedValue;\n}\n\n/**\n * This function validates all body data specified in the arguments\n *\n * @param valueOf - true stops returning the data to its primitive value of its instance\n * @param reqBody - request body\n * ```json\n * {email: \"example@sandwich.com\"}\n * ```\n * @param schemes - schemes of validation `{ email: {type: Sandwich.String, strict: true} }`\n */\nexport async function argument(\n    valueOf: boolean, reqBody: object, schemes?: VA.schemes\n): Promise<AR.argumentProps> {\n    const resp = {};\n    const body = {};\n    const errors: VE.ErrorStatus[] = []\n\n    if(!schemes) exception({message: `schemes is ${schemes}`}, 500)\n\n    for (const key in schemes) {\n        const scheme = schemes[key] ?? null;\n        if(scheme) {\n            \n            const validated = await validArgument({\n                value: getValue(reqBody, scheme, key),\n                key: key,\n                message: scheme['message'] ?? null,\n                scheme: scheme\n            });\n\n            Object.defineProperty(resp, key, {\n                enumerable: true,\n                value: validated\n            });\n\n            Object.defineProperty(body, key, {\n                enumerable: true,\n                value: valueOf || !validated.value ? validated.value : validated.value.valueOf()\n            });\n\n            if (validated.errors.length) {\n                errors.push({[key]: validated.errors})\n            }\n\n        }\n    }\n\n    return {\n        argument: resp,\n        body,\n        errors\n    };\n}\n","import {TypeValid} from \"../functions/validator\";\n\n/**\n * Types of validations\n */\nclass Types implements TypeValid {\n    static String = String\n    static Number = Number\n    static Array = Array\n    static Boolean = Boolean\n    static Object = Object\n    String = String\n    Number = Number\n    Array = Array\n    Boolean = Boolean\n    Object = Object\n}\n\nexport default Types;","import {argument} from \"./argument\";\nimport {verifyErrors} from \"./verifyErrors\";\nimport Types from \"./type\";\nimport {\n    ParserSchemeFunction,\n    HandlerParserSchemes,\n    valuesArgs,\n    schemes,\n    valueOf,\n    LettuceInterface\n} from \"../functions/validator\";\n\n/**\n * Analyze the values provided according to your schema.\n *\n * @param valueOf - Determines how validated arguments and parameters are extracted.\n * @param schemes - schemes\n * ```json\n * {\n *     email: {type: Sandwich.String, required: true, strict: true},\n *     password: {type: Sandwich.String, required: true, strict: true, min: 8}\n * }\n * ```\n * @param values - data body request.\n * @returns HandlerParserSchemes\n */\nexport const parserSchemes: HandlerParserSchemes = async (\n    valueOf, schemes, values\n) => {\n    const\n        /**\n         *  validate data\n         *\n         * @param result_argument - result argument\n         */\n        result_argument = await argument(valueOf ?? true, values ?? {}, schemes),\n\n        /**\n         * check for errors in arguments\n         *\n         * @param responseError - bug check response\n         */\n        responseError = await verifyErrors(result_argument.errors);\n\n    return {\n        schemes: result_argument.argument,\n        args: result_argument.body,\n        errors: responseError.errors,\n        message: responseError.message\n    }\n}\n\n\n/**\n * A Validators class, with functions that allow rigorously validating\n * data, according to a specific pattern (a schema).\n *\n * @remarks\n * A schema determines the validation pattern of a value, and if it\n * does not meet the conditions of the pattern, an exception is\n * thrown with the return of an array of the errors found.\n *\n * @beta\n */\nexport class Lettuce extends Types implements LettuceInterface {\n\n    /**\n     * values to be validated\n     * @defaultValue undefined\n     */\n    values: valuesArgs = undefined;\n\n    /**\n     * Object type property. List of validation schemes.\n     * @defaultValue object\n     */\n    schemes: schemes;\n\n    /**\n     * Boolean type property. Determines how validated arguments\n     * and parameters are extracted.\n     * @defaultValue true\n     */\n    valueOf: valueOf = true;\n\n    /**\n     * Creates an instance of Sandwiches.\n     */\n    constructor(schemes?: schemes) {\n        super();\n        this.schemes = schemes ?? null;\n    }\n\n    /**\n     * parse and validate request body data\n     *\n     * @param values - Data subject to validation\n     * @returns ParserSchemesResponse\n     */\n    parserSchemes(values?: valuesArgs): ParserSchemeFunction\n    {\n        return parserSchemes(\n            this.valueOf, this.schemes, this.values ?? values\n        )\n    }\n\n    /**\n     * Reset data:\n     * ```ts\n     *  this.valueOf = true;\n     *  this.schemes = {};\n     *  this.values = undefined;\n     * ```\n     */\n    reset() {\n        this.valueOf = true;\n        this.schemes = null;\n        this.values = undefined;\n    }\n}\n\nexport default Lettuce;\n","import {\n    ParserSchemeFunction,\n    valuesArgs,\n    schemes,\n    scheme,\n    FuncResolvePromiseScheme,\n    resolvePromiseScheme,\n    ParserLettuceInterface\n} from \"../functions/validator\";\nimport Lettuce from './lettuce'\n\nconst validator = new Lettuce();\n\n/**\n * addSchemes add schemes\n *\n * @privateRemarks\n * addSchemes function serving the ParserLettuce class for\n * adding validation schemes\n *\n * @param schemes - Validation schemes\n */\nconst addSchemes = (schemes: unknown) => {\n    validator.schemes = Object.assign(validator.schemes ?? {}, schemes);\n}\n\n/**\n * handle the function addScheme, which belongs to the class ParserSchemes\n *\n * @param callBack - receives as argument the resolution function of\n * new Promise, and the value processed in the callback is passed to\n * it, this value is the validation scheme of an element\n */\nconst handlerAddScheme = (callBack: FuncResolvePromiseScheme) => {\n    new Promise((resolve) => {\n        callBack(resolve);\n    }).then((schemes: unknown) => {\n        addSchemes(schemes);\n    });\n}\n\n/**\n * Processes and assigns to validator.schemes the validation\n * schemes declared as property in a class.\n *\n * @param schemesEntries - Matrix of schemes\n *\n * @example\n * Matrix schemes:\n * ```json\n * [\n *  ['name' {type: Type.String, required: true, strict: true}],\n *  ['email' {type: Type.String, required: true, strict: true}]\n * ]\n * ```\n */\nconst addPropertySchemesValidator = <T>(schemesEntries: [keyof T, T[keyof T]][]): Promise<void> => {\n    return new Promise((resolve) => {\n        resolve(Object.fromEntries(schemesEntries));\n    }).then((schemeData) => {\n        validator.schemes = Object.assign(validator.schemes, schemeData);\n    })\n}\n\nexport class ParserLettuce implements ParserLettuceInterface {\n\n    /**\n     * instance ParserLettuce\n     */\n    constructor(valueOf?: boolean) {\n        validator.reset();\n        validator.valueOf = valueOf ?? true;\n    }\n\n    /**\n     * Activating the schema validation functions\n     */\n    parserSchemes(values?: valuesArgs): ParserSchemeFunction {\n        return addPropertySchemesValidator(Object.entries(this))\n            .then(()=> validator.parserSchemes(values));\n    }\n\n    /**\n     * add schemes\n     *\n     * @param schemes - Validations schemes\n     */\n    addSchemes(schemes: schemes) {\n        addSchemes(schemes);\n    }\n\n    /**\n     * The addScheme property must be represented in the child class as a function\n     * within this function the schemas are loaded for the validation of the arguments\n     *\n     * @example\n     *```ts\n     * addScheme({type: Sandwich.String, required: true, strict: true}, ['email'])\n     *```\n     * @param scheme - Validations scheme\n     * @param arg - Name of the argument to validate, can be a string or an array of strings.\n     *\n     * @example\n     * example param arg:\n     * ```ts\n     * 'password' or ['password', 'passwordConfirm']\n     * ```\n     *\n     */\n    addScheme(scheme: scheme, arg: string | string[]) {\n        handlerAddScheme((add: resolvePromiseScheme): void => {\n            if(typeof arg == 'string') {\n                add({\n                    [arg]: scheme\n                });\n            } else {\n                let sh = {}\n                for (let i = 1; i <= arg.length; i++) {\n                    sh = {\n                        [arg[i -1]]: scheme,\n                        ...sh\n                    }\n                    if(i == arg.length) add(sh);\n                }\n            }\n        });\n    }\n}\n"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","validate","Map","set","elm","Array","isArray","Object","toString","call","exception","response","code","error","errors","responseServerError","verifyErrors","message","length","messageArgument","props","replace","key","type","toLowerCase","funcArguments","value","func","scheme","name","from","includes","validType","strict","required","valid","get","validData","validValue","keyValid","Promise","resolve","keyMain","validArguments","ejectMessage","validExtractArgument","validResponse","resp","push","validRespArgument","validArgument","success","getValue","reqBody","definedValue","argument","valueOf","schemes","body","validated","defineProperty","enumerable","String","Number","Boolean","values","undefined","parserSchemes","result_argument","responseError","args","reset","validator","addSchemes","assign","schemesEntries","entries","fromEntries","then","schemeData","addScheme","arg","callBack","add","sh","i"],"sourceRoot":""}