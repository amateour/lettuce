{"version":3,"file":"index.umd.js","mappings":"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","sources":["webpack://@amateury/lettuce/webpack/universalModuleDefinition","webpack://@amateury/lettuce/webpack/bootstrap","webpack://@amateury/lettuce/webpack/runtime/define property getters","webpack://@amateury/lettuce/webpack/runtime/hasOwnProperty shorthand","webpack://@amateury/lettuce/webpack/runtime/make namespace object","webpack://@amateury/lettuce/./src/help.ts","webpack://@amateury/lettuce/./src/util.ts","webpack://@amateury/lettuce/./src/parser.ts","webpack://@amateury/lettuce/./src/lettuce.ts","webpack://@amateury/lettuce/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@amateury/lettuce\"] = factory();\n\telse\n\t\troot[\"@amateury/lettuce\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export type TIsValidate = (elm: any) => boolean;\n\n/**\n * validate if it is an array\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isArray(elm: any): boolean {\n  return Array.isArray(elm);\n}\n\n/**\n * validate if it is an objet\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isObject(elm: any): boolean {\n  return elm instanceof Object;\n}\n\n/**\n * validate if it is an string\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isString(elm: any): boolean {\n  return typeof elm === \"string\";\n}\n\n/**\n * validate if it is a number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isNumber(elm: any): boolean {\n  return typeof elm === \"number\";\n}\n\n/**\n * validate if it is a number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isBoolean(elm: any): boolean {\n  return typeof elm === \"boolean\";\n}\n\n/**\n * Functions validations (isArray, isString)\n *\n */\nexport const validate = new Map<string, TIsValidate>();\nvalidate.set(\"Array\", isArray);\nvalidate.set(\"String\", isString);\nvalidate.set(\"Number\", isNumber);\nvalidate.set(\"Object\", isObject);\nvalidate.set(\"Boolean\", isBoolean);\nvalidate.set(\"MyNumberType\", isNumber);\n","export type TKey = string | number;\n\nexport interface TTripArg {\n  value: any;\n  key: TKey;\n  thing: any;\n  len: number;\n  index: number;\n}\n\n/**\n * traverse an object\n * @param thing - Object\n * @param callBack - callback function\n */\nexport async function trip(thing: any, callBack: (arg: TTripArg) => any) {\n  const keys: TKey[] = Object.keys(thing);\n  let len: number = keys.length + 1;\n  while (--len) {\n    const index: number = keys.length - len;\n    const key = keys[index];\n    const value = thing[key];\n    const resp = await callBack({ value, key, thing, index, len });\n    if (resp !== undefined) return resp;\n  }\n}\n\nexport function capitalizeWord(str: string) {\n  const val = str.toLowerCase();\n  return val.charAt(0).toUpperCase() + val.slice(1);\n}\n","import { validate, isBoolean } from \"./help\";\nimport { capitalizeWord, trip } from \"./util\";\n\ntype TTarget = string | number;\ntype TRegex = RegExp;\ntype TType = any | any[];\n\nexport interface IScheme {\n  target: TTarget;\n  type: TType;\n  required?: boolean;\n  min?: number;\n  max?: number;\n  value?: ((value: any) => any) | any;\n  strict?: boolean;\n  regex?: TRegex;\n  message?: any;\n}\n\nexport type TValue = any;\n\n/**\n * Values\n */\nexport type TValues = {\n  [index: TTarget]: TValue;\n};\n\nexport type TStrictCycle = boolean | number;\n\n/**\n * Config\n */\nexport type TConfig =\n  | {\n      strictCycle?: TStrictCycle;\n    }\n  | null\n  | undefined;\n\nenum TypesErrors {\n  type = \"type\",\n  min = \"min\",\n  max = \"max\",\n  required = \"required\",\n  regex = \"regex\",\n}\n\nexport type TErrorVal = string;\n\nexport type TErrors = {\n  error: TErrorVal[];\n  target: TTarget;\n  value: any | any[];\n};\n\n/**\n * Run a bug\n * @param e - Error\n */\nconst error = (e: any) => {\n  throw e;\n};\n\n/**\n * Generate new Error\n * @param e - Error\n */\nconst newError = (e: any) => {\n  error(new Error(e));\n};\n\n/**\n * Validate is required\n * @param required - Value required (boolean)\n * @param val - Value of validation\n */\nconst isRequired = async (\n  required: boolean | undefined,\n  val: TValue\n): Promise<void> => {\n  if (required && !val && !isBoolean(val)) error(TypesErrors.required);\n};\n\n/**\n * In this function, the custom data type is validated through\n * the static method __validate__.\n * @param val - Value of validation\n * @param type - Data type\n */\nconst customValidateValue = async (val: TValue, type: TType) => {\n  try {\n    const valid = await type.__validate__(val);\n    /* istanbul ignore else */\n    if (!valid) {\n      error(TypesErrors.type);\n    }\n  } catch (e) {\n    if (e === TypesErrors.type) error(e);\n    newError(`No validation custom format found: ${e}`);\n  }\n};\n/**\n * Validate data type\n * @param scheme - Type to validation\n * @param val - Value of validation\n * @param type - Data type\n */\nconst validateValueType = async (\n  scheme: IScheme,\n  val: TValue,\n  type: TType\n): Promise<TValue> => {\n  // It is a boolean to know if the data will be strictly validated\n  if (scheme.strict) {\n    const validateStrict = validate.get(type.name);\n    if (validateStrict) {\n      if (!validateStrict(val)) error(TypesErrors.type);\n    } else {\n      await customValidateValue(val, type);\n    }\n  }\n\n  let formatVal: TValue = val;\n  if (type.name === \"Array\") {\n    formatVal = val ? type.from(val) : val;\n  } else if (Object.prototype.hasOwnProperty.call(type, \"__validate__\")) {\n    await customValidateValue(val, type);\n  } else {\n    formatVal = val ? type(val) : val;\n  }\n\n  return formatVal;\n};\n\n/**\n * Validate data type\n * @param scheme - Type to validation\n * @param val - Value of validation\n * @param type - Data type\n */\nconst valuePick = async (scheme: IScheme, val: TValue, type: TType) => {\n  type TTripArg = { value: TValue; len: number };\n  if (!type.length && type.length !== undefined) error(TypesErrors.type);\n  return await trip(type, async ({ value, len }: TTripArg) => {\n    if (value instanceof Function) {\n      try {\n        return await validateValueType(scheme, val, value);\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n    } else {\n      if (val === value) return val;\n      else if (typeof value === \"object\" && value) {\n        const resultValid = await trip(value, ({ value: v }) => v === val);\n        /* istanbul ignore else */\n        if (resultValid) return val;\n      }\n    }\n    if (len === 1) error(TypesErrors.type);\n  });\n};\n\n/**\n * Formats the target value to the specified type\n * @param scheme - Type to validation\n * @param val - Value of validation\n */\nconst valueType = async (scheme: IScheme, val: TValue): Promise<TValue> => {\n  const type = scheme.type; // Type to validation\n  return await (typeof type === \"object\"\n    ? valuePick(scheme, val, type)\n    : validateValueType(scheme, val, type));\n};\n\n/**\n * Evaluate minimum value\n * @param val - Value of validation\n * @param min - Value of minimum (number)\n * @param typeName - Name function type\n */\nconst min = async (val: TValue, min: number, typeName: string) => {\n  let validMin = null;\n  const _typeName = capitalizeWord(typeName);\n  if (val.length) {\n    validMin = val.length >= min;\n  } else if (_typeName === \"Number\" || _typeName === \"BigInt\") {\n    validMin = val >= min;\n  }\n  if ((validMin !== null && !validMin) || !validMin) error(TypesErrors.min);\n  return validMin;\n};\n\n/**\n * Evaluate maximum value\n * @param val - Value of validation\n * @param max - Value of maximum (number)\n * @param typeName - Name function type\n */\nconst max = async (val: TValue, max: number, typeName: string) => {\n  let validMin = null;\n  const _typeName = capitalizeWord(typeName);\n  if (val.length) {\n    validMin = val.length <= max;\n  } else if (_typeName === \"Number\" || _typeName === \"BigInt\") {\n    validMin = val <= max;\n  }\n  if ((validMin !== null && !validMin) || !validMin) error(TypesErrors.max);\n  return validMin;\n};\n\nconst regexValid = async (val: TValue, reg: TRegex) => {\n  if (!reg.test(val)) error(TypesErrors.regex);\n};\n\n/**\n * Extra validation: minimum value, maximum value, regex\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n * @param typeName - Name function type\n * @param callBack -\n */\nasync function extraValidation(\n  scheme: IScheme,\n  val: TValue,\n  typeName: string,\n  callBack: any\n): Promise<TValue> {\n  const valIsValid = scheme.required\n    ? scheme.required\n    : !(!val && !scheme.required);\n  if (scheme.min && valIsValid)\n    await min(val, scheme.min, typeName).catch(callBack);\n  if (scheme.max && valIsValid)\n    await max(val, scheme.max, typeName).catch(callBack);\n  if (scheme.regex && valIsValid)\n    await regexValid(val, scheme.regex).catch(callBack);\n\n  return val;\n}\n\n/**\n * Add the default value, set the value property, the value property can be a\n * function and will be interpreted as a callback\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n */\nconst valueDefault = async (scheme: IScheme, val: TValue): Promise<TValue> => {\n  if (scheme.value && scheme.value instanceof Function)\n    return await scheme.value(val);\n  return scheme.value !== undefined && !val ? scheme.value : val;\n};\n\ntype TRValidScheme = [TValue, TErrorVal[]];\n\n/**\n * Function that validates the value against the schema data\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n */\nasync function validScheme(\n  scheme: IScheme,\n  val: TValue\n): Promise<TRValidScheme> {\n  const errors: TErrorVal[] = [];\n  const pushError = (e: any) => {\n    if (e in TypesErrors) {\n      errors.push(e);\n    } else {\n      error(e);\n    }\n  };\n\n  await isRequired(scheme.required, val).catch(pushError);\n  const formatVal = await valueType(scheme, val).catch(pushError);\n\n  if (errors.length) return [formatVal, errors];\n\n  const typeName = typeof formatVal;\n  const respVal = await extraValidation(scheme, formatVal, typeName, pushError);\n  return [respVal, errors];\n}\n\ntype TResolution = (value: [TTarget, TValue]) => void;\ntype TCallBackErr = (value: TErrors, index: number) => void;\n\n/**\n * Function that serves as a bridge between validScheme and parserScheme\n * @param resolution - callback that sets the resolved values\n * @param callBackErr - callback that sets the values with error\n * @param scheme - Scheme\n * @param val - Value of validation\n * @param index - Counting rate\n */\nasync function runValidation(\n  resolution: TResolution,\n  callBackErr: TCallBackErr,\n  scheme: IScheme,\n  val: any,\n  index: number\n) {\n  await validScheme(scheme, val).then(([value, errors]) => {\n    if (!errors.length) {\n      resolution([scheme.target, value]);\n    } else {\n      const er = {\n        error: errors,\n        target: scheme.target,\n        value: val,\n      };\n      callBackErr(er, index);\n    }\n  });\n}\n\n/**\n * Assign default values to a schema\n * @param scheme - Schemes\n */\nconst defaultScheme = (scheme: IScheme) => ({\n  required: true,\n  strict: true,\n  ...scheme,\n});\n\n/**\n * Analyze the values provided according to your schema.\n * @param schemes - Schemes\n * @example\n * Example of a schematic:\n *```json\n *[\n *  { target: \"email\", type: String, required: true, strict: true},\n *  { target: \"name\", type: String, required: true, strict: true, min: 8, max: 80},\n *  { target: \"password\", type: String, required: true, strict: true, min: 8},\n *]\n *```\n * @param values - Data to validate\n * @example\n * Example of a data to validate:\n * ```json\n * {\n *   email: \"lettuce@lettuce.com\",\n *   name: \"Lettuce\",\n *   password: \"sW6LT#Fh\",\n * }\n * ```\n * @param config - Config\n */\nexport async function parserScheme(\n  schemes: IScheme[],\n  values: TValues = {},\n  config: TConfig\n) {\n  type TFun = {\n    _values: TValues;\n    values: TValues;\n    _errors: TErrors[];\n    resolution: TResolution;\n    callBackErr: TCallBackErr;\n  };\n\n  const fun: TFun = {\n    _values: {},\n    _errors: [],\n    get values(): TValues {\n      return this._values;\n    },\n    resolution([target, val]: [TTarget, TValue]): void {\n      if (val !== undefined)\n        Object.defineProperty(fun._values, target, {\n          enumerable: true,\n          value: val,\n        });\n    },\n    callBackErr(value: TErrors, index: number) {\n      fun._errors.push(value);\n      if (\n        (config &&\n          config.strictCycle &&\n          typeof config.strictCycle === \"boolean\") ||\n        (config && config.strictCycle === index + 1)\n      ) {\n        error(fun._errors);\n      }\n    },\n  };\n\n  await trip(schemes, async ({ value, index }) => {\n    const scheme = defaultScheme(value);\n    const val = await valueDefault(scheme, values[scheme.target]);\n    await runValidation(fun.resolution, fun.callBackErr, scheme, val, index);\n  });\n\n  return fun._errors.length ? error(fun._errors) : fun.values;\n}\n","import * as parser from \"./parser\";\n\ninterface TParamConstructor {\n  values?: parser.TValues;\n  strictCycle?: parser.TStrictCycle;\n}\n\ninterface ILettuce {\n  readonly schemes: parser.IScheme[];\n  values?: parser.TValues;\n  config?: parser.TConfig;\n}\n\nclass Lettuce implements ILettuce {\n  /**\n   * Object type property. List of validation schemes.\n   * @defaultValue object\n   */\n  schemes: parser.IScheme[];\n\n  /**\n   * values to be validated\n   * @defaultValue null\n   */\n  values?: parser.TValues;\n  config?: parser.TConfig;\n\n  /**\n   * Creates an instance of Lettuce.\n   * @param schemas - Schemas validation\n   * @param crossing - Configuration data, and optional for validation\n   */\n  constructor(schemas: parser.IScheme[], crossing?: TParamConstructor) {\n    const { values, strictCycle } = crossing ?? {};\n    this.schemes = schemas;\n    if (values) this.values = values;\n    if (strictCycle) this.config = { strictCycle };\n  }\n\n  async parser(\n    values?: parser.TValues,\n    strictCycle?: parser.TStrictCycle\n  ): Promise<any> {\n    if (values) this.values = values;\n    if (strictCycle) this.config = { ...this.config, strictCycle };\n    return parser.parserScheme(this.schemes, this.values, this.config);\n  }\n}\n\nexport default Lettuce;\n","export * from \"./parser\";\nimport Lettuce from \"./lettuce\";\n\nexport default Lettuce;\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isNumber","elm","isBoolean","validate","Map","set","Array","isArray","trip","thing","callBack","keys","len","length","index","undefined","resp","capitalizeWord","str","val","toLowerCase","charAt","toUpperCase","slice","TypesErrors","error","e","isRequired","required","customValidateValue","type","__validate__","Error","validateValueType","scheme","strict","validateStrict","name","formatVal","from","valuePick","Function","valueType","min","typeName","validMin","_typeName","max","regexValid","reg","test","regex","extraValidation","valIsValid","catch","valueDefault","validScheme","errors","pushError","push","runValidation","resolution","callBackErr","then","er","target","parserScheme","schemes","values","config","fun","_values","_errors","this","strictCycle","defaultScheme","schemas","crossing","parser"],"sourceRoot":""}