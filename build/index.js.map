{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@amateury/lettuce/webpack/bootstrap","webpack://@amateury/lettuce/webpack/runtime/define property getters","webpack://@amateury/lettuce/webpack/runtime/hasOwnProperty shorthand","webpack://@amateury/lettuce/webpack/runtime/make namespace object","webpack://@amateury/lettuce/./src/help.ts","webpack://@amateury/lettuce/./src/parser.ts","webpack://@amateury/lettuce/./src/lettuce.ts","webpack://@amateury/lettuce/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export type TIsValidate = (elm: any) => boolean;\n\n/**\n * validate if it is an array\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isArray(elm: any): boolean {\n  return Array.isArray(elm);\n}\n\n/**\n * validate if it is an objet\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isObject(elm: any): boolean {\n  return elm instanceof Object;\n}\n\n/**\n * validate if it is an string\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isString(elm: any): boolean {\n  return typeof elm === \"string\";\n}\n\n/**\n * validate if it is a number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isNumber(elm: any): boolean {\n  return typeof elm === \"number\";\n}\n\n/**\n * validate if it is a number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isBoolean(elm: any): boolean {\n  return typeof elm === \"boolean\";\n}\n\n/**\n * Functions validations (isArray, isString)\n *\n */\nexport const validate = new Map<string, TIsValidate>();\nvalidate.set(\"Array\", isArray);\nvalidate.set(\"String\", isString);\nvalidate.set(\"Number\", isNumber);\nvalidate.set(\"Object\", isObject);\nvalidate.set(\"Boolean\", isBoolean);\n","import { validate, isBoolean } from \"./help\";\n\ntype TTarget = string | number;\ntype TRegex = RegExp;\ntype TType = any;\n\nexport interface IScheme {\n  target: TTarget;\n  type: TType;\n  required?: boolean;\n  min?: number;\n  max?: number;\n  value?: ((value: any) => any) | any;\n  strict?: boolean;\n  regex?: TRegex;\n  message?: any;\n}\n\nexport type TValue = any;\n\n/**\n * Values\n */\nexport type TValues = {\n  [index: TTarget]: TValue;\n};\n\nexport type TErrorVal = string;\n\nexport type TErrors = {\n  error: TErrorVal[];\n  target: TTarget;\n  value: any | any[];\n};\n\n/**\n * Run a bug\n * @param e - Error\n */\nconst error = (e: any) => {\n  throw e;\n};\n\n/**\n * Validate is required\n * @param required - Value required (boolean)\n * @param val - Value of validation\n */\nconst isRequired = async (\n  required: boolean | undefined,\n  val: TValue\n): Promise<void> => {\n  if (required && !val && !isBoolean(val)) error(\"required\");\n};\n\n/**\n * In this function, the custom data type is validated through\n * the static method __validate__.\n * @param val - Value of validation\n * @param type - Data type\n */\nconst customValidateValue = async (val: TValue, type: TType) => {\n  try {\n    const valid = await type.__validate__(val);\n    /* istanbul ignore else */\n    if (!valid) {\n      error(\"type\");\n    }\n  } catch (e) {\n    if (e === \"type\") error(e);\n    error(`No validation custom format found: ${e}`);\n  }\n};\n/**\n * Validate data type\n * @param scheme - Type to validation\n * @param val - Value of validation\n * @param type - Data type\n * @param strict - It is a boolean to know if the data will be\n * strictly validated\n */\nconst validateValueType = async (\n  scheme: IScheme,\n  val: TValue,\n  type: TType,\n  strict: boolean | undefined\n): Promise<TValue> => {\n  if (strict) {\n    const validateStrict = validate.get(type.name);\n    if (validateStrict) {\n      if (!validateStrict(val)) error(\"type\");\n    } else {\n      await customValidateValue(val, type);\n    }\n  }\n\n  let formatVal: any;\n  if (type.name === \"Array\") {\n    formatVal = val ? type.from(val) : val;\n  } else {\n    formatVal = val ? type(val) : val;\n  }\n  return val\n    ? await complementaryValidation(scheme, formatVal, type.name)\n    : val;\n};\n\n/**\n * Validate data type\n * @param scheme - Type to validation\n * @param val - Value of validation\n * @param type - Data type\n */\nconst valuePick = async (scheme: IScheme, val: TValue, type: TType) => {\n  const keys = Object.keys(type);\n  let len: number = keys.length + 1;\n  while (--len) {\n    const typeOrPick = type[keys[keys.length - len]];\n    if (typeOrPick instanceof Function) {\n      const nameFuncType = typeOrPick.name;\n      try {\n        const nameFuncTypeLCase = nameFuncType.toString().toLocaleLowerCase();\n        /* istanbul ignore else */\n        if (nameFuncTypeLCase === typeof val) {\n          return await validateValueType(scheme, val, typeOrPick, undefined);\n        }\n        // eslint-disable-next-line no-empty\n      } finally {\n      }\n    } else {\n      if (val === typeOrPick) return val;\n    }\n    if (len === 1) error(\"pick\");\n  }\n};\n\n/**\n * Formats the target value to the specified type\n * @param scheme - Type to validation\n * @param val - Value of validation\n */\nconst valueType = async (scheme: IScheme, val: TValue): Promise<TValue> => {\n  const type = scheme.type; // Type to validation\n  const strict = scheme.strict; //Validation strict\n  if (typeof type === \"object\") return await valuePick(scheme, val, type);\n  return await validateValueType(scheme, val, type, strict);\n};\n\n/**\n * Evaluate minimum value\n * @param val - Value of validation\n * @param min - Value of minimum (number)\n * @param typeName - Name function type\n */\nconst min = async (val: TValue, min: number, typeName: string) => {\n  let validMin = null;\n  if (val.length) {\n    validMin = val.length >= min;\n  } else if (typeName === \"Number\" || typeName === \"BigInt\") {\n    validMin = val >= min;\n  }\n  if (validMin !== null && !validMin) error(\"min\");\n  if (!validMin)\n    error(\n      `it is not possible to evaluate the minimum value for the type: ${typeof val}`\n    );\n  return validMin;\n};\n\n/**\n * Evaluate maximum value\n * @param val - Value of validation\n * @param max - Value of maximum (number)\n * @param typeName - Name function type\n */\nconst max = async (val: TValue, max: number, typeName: string) => {\n  let validMin = null;\n\n  if (val.length) {\n    validMin = val.length <= max;\n  } else if (typeName === \"Number\" || typeName === \"BigInt\") {\n    validMin = val <= max;\n  }\n  if (validMin !== null && !validMin) error(\"max\");\n  if (!validMin)\n    error(\n      `it is not possible to evaluate the maximum value for the type: ${typeof val}`\n    );\n\n  return validMin;\n};\n\nconst regexValid = async (val: TValue, reg: TRegex) => {\n  if (!reg.test(val)) error(\"regex\");\n};\n\n/**\n * Complementary validation: minimum value, maximum value\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n * @param typeName - Name function type\n */\nasync function complementaryValidation(\n  scheme: IScheme,\n  val: TValue,\n  typeName: string\n): Promise<TValue> {\n  if (scheme.min) await min(val, scheme.min, typeName);\n  if (scheme.max) await max(val, scheme.max, typeName);\n  if (scheme.regex) await regexValid(val, scheme.regex);\n\n  return val;\n}\n\n/**\n * Add the default value, set the value property, the value property can be a\n * function and will be interpreted as a callback\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n */\nconst valueDefault = async (scheme: IScheme, val: TValue): Promise<TValue> => {\n  if (scheme.value && scheme.value instanceof Function)\n    return await scheme.value(val);\n  return scheme.value !== undefined && !val ? scheme.value : val;\n};\n\ntype TRValidScheme = [TErrorVal[], TValue];\n\n/**\n * Function that validates the value against the schema data\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n */\nasync function validScheme(\n  scheme: IScheme,\n  val: TValue\n): Promise<TRValidScheme> {\n  const errors: TErrorVal[] = [];\n  const strict = scheme.strict;\n\n  await isRequired(scheme.required, val).catch((e: any) => error(e));\n\n  return await valueType(scheme, val)\n    .catch((e: any) => {\n      strict ? error(e) : errors.push(e);\n    })\n    .then((resp) => [errors, resp ?? val]);\n}\n\ntype TResolution = (value: [TTarget, TValue]) => void;\ntype TCallBackErr = (value: TErrors) => void;\n\n/**\n * Function that serves as a bridge between validScheme and parserScheme\n * @param resolution - callback that sets the resolved values\n * @param callBackErr - callback that sets the values with error\n * @param scheme - Scheme\n * @param val - Value of validation\n */\nasync function runValidation(\n  resolution: TResolution,\n  callBackErr: TCallBackErr,\n  scheme: IScheme,\n  val: any\n) {\n  await validScheme(scheme, val)\n    .then(([err, value]) => {\n      if (err.length) {\n        return callBackErr({\n          error: [...err],\n          target: scheme.target,\n          value: val,\n        });\n      }\n      resolution([scheme.target, value]);\n    })\n    .catch((e) => {\n      error([\n        {\n          error: [e],\n          target: scheme.target,\n          value: val,\n        },\n      ]);\n    });\n}\n\n/**\n * Analyze the values provided according to your schema.\n * @param schemes - Schemes\n * @example\n * Example of a schematic:\n *```json\n *[\n *  { target: \"email\", type: String, required: true, strict: true},\n *  { target: \"name\", type: String, required: true, strict: true, min: 8, max: 80},\n *  { target: \"password\", type: String, required: true, strict: true, min: 8},\n *]\n *```\n * @param values - Data to validate\n * @example\n * Example of a data to validate:\n * ```json\n * {\n *   email: \"lettuce@lettuce.com\",\n *   name: \"Lettuce\",\n *   password: \"sW6LT#Fh\",\n * }\n * ```\n */\nexport async function parserScheme(schemes: IScheme[], values: TValues = {}) {\n  let len = schemes.length + 1;\n\n  type TFun = {\n    _values: TValues;\n    values: TValues;\n    _errors: TErrors[];\n    resolution: TResolution;\n    callBackErr: TCallBackErr;\n  };\n\n  const fun: TFun = {\n    _values: {},\n    _errors: [],\n    get values(): TValues {\n      return this._values;\n    },\n    resolution([target, val]: [TTarget, TValue]): void {\n      if (val !== undefined)\n        Object.defineProperty(fun._values, target, {\n          enumerable: true,\n          value: val,\n        });\n    },\n    callBackErr(value: TErrors) {\n      fun._errors.push(value);\n    },\n  };\n\n  while (--len) {\n    const scheme = schemes[schemes.length - len];\n    const val = await valueDefault(scheme, values[scheme.target]);\n    await runValidation(fun.resolution, fun.callBackErr, scheme, val);\n  }\n  return fun._errors.length ? error(fun._errors) : fun.values;\n}\n","import * as parser from \"./parser\";\n\ninterface ILettuce {\n  readonly schemes: parser.IScheme[];\n  values?: parser.TValues;\n}\n\nclass Lettuce implements ILettuce {\n  /**\n   * Object type property. List of validation schemes.\n   * @defaultValue object\n   */\n  schemes: parser.IScheme[];\n\n  /**\n   * values to be validated\n   * @defaultValue null\n   */\n  values?: parser.TValues;\n\n  /**\n   * Creates an instance of Lettuce.\n   */\n  constructor(schemas: parser.IScheme[], values?: parser.TValues) {\n    this.schemes = schemas;\n    if (values) this.values = values;\n  }\n\n  async parser(values?: parser.TValues): Promise<any> {\n    if (values) this.values = values;\n    return parser.parserScheme(this.schemes, this.values);\n  }\n}\n\nexport default Lettuce;\n","export * from \"./parser\";\nimport Lettuce from \"./lettuce\";\n\nexport default Lettuce;\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isBoolean","elm","validate","Map","set","Array","isArray","error","e","isRequired","required","val","customValidateValue","type","__validate__","validateValueType","scheme","strict","validateStrict","name","formatVal","from","complementaryValidation","valuePick","keys","len","length","typeOrPick","Function","nameFuncType","toString","toLocaleLowerCase","undefined","valueType","min","typeName","validMin","max","regexValid","reg","test","regex","valueDefault","validScheme","errors","catch","push","then","resp","runValidation","resolution","callBackErr","err","target","parserScheme","schemes","values","fun","_values","_errors","this","schemas","parser"],"sourceRoot":""}