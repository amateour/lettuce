{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@amateour/lettuce/webpack/bootstrap","webpack://@amateour/lettuce/webpack/runtime/define property getters","webpack://@amateour/lettuce/webpack/runtime/global","webpack://@amateour/lettuce/webpack/runtime/hasOwnProperty shorthand","webpack://@amateour/lettuce/webpack/runtime/make namespace object","webpack://@amateour/lettuce/./src/help.ts","webpack://@amateour/lettuce/./src/verifyErrors.ts","webpack://@amateour/lettuce/./src/argument.ts","webpack://@amateour/lettuce/./src/type.ts","webpack://@amateour/lettuce/./src/lettuce.ts","webpack://@amateour/lettuce/./src/parserLettuce.ts","webpack://@amateour/lettuce/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as SW from '../functions/help';\n\n/**\n * Identify if it is running in a browser\n */\nexport const isBrowser: () => boolean = () => typeof window !== 'undefined'\n    && ({}).toString.call(window) === '[object Window]';\n\n/**\n * Identify if it is running in a nodejs\n */\nexport const isNode: () => boolean = () => typeof global !== \"undefined\"\n    && ({}).toString.call(global) === '[object global]';\n\n/**\n * validate if it is an array\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isArray(elm: any): boolean {\n    return Array.isArray(elm);\n}\n\n/**\n * validate if it is an objet\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isObject(elm: any): boolean {\n    return elm instanceof Object;\n}\n\n/**\n * validate if it is an string\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isString(elm: any): boolean {\n    return typeof elm === \"string\";\n}\n\n/**\n * validate if it is an number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isNumber(elm: any): boolean {\n    return typeof elm === \"number\";\n}\n\n/**\n * Functions validations (isArray, isString)\n *\n */\nexport const validate = new Map<string, SW.isValid>();\nvalidate.set('Array', isArray);\nvalidate.set('String', isString);\nvalidate.set('Number', isNumber);\nvalidate.set('Object', isObject);\nvalidate.set('Browser', isBrowser);\nvalidate.set('Browser', isNode);\n\n","import {ResponseVerifyErrors, ErrorStatus} from \"../functions/verifyErrors\";\n\nfunction error(response: ResponseVerifyErrors): ResponseVerifyErrors {\n    throw response;\n}\n\nfunction responseServerError(response: ResponseVerifyErrors, code: number): ResponseVerifyErrors {\n    const {message, errors} = response;\n    throw {\"statusCode\": code, \"message\": message, errors};\n}\n\nexport function exception(response: ResponseVerifyErrors, code: number) {\n    typeof window !== 'undefined'\n    && ({}).toString.call(window) === '[object Window]'\n        ? error(response) : responseServerError(response, code);\n}\n\n/**\n * validate errors and send message\n *\n * @param errors -\n */\nexport async function verifyErrors(\n    errors: ErrorStatus[]\n): Promise<ResponseVerifyErrors | any> {\n\n    const response: ResponseVerifyErrors = {\n        errors: [],\n        message: 'args_validation_successful'\n    }\n\n    if (errors.length) {\n        response.errors = errors;\n        response.message = 'args_validation_errors';\n        exception(response, 400);\n    } else {\n        return response\n    }\n}\n","import * as AR from '../functions/arguments';\nimport * as VA from '../functions/validator';\nimport * as VE from '../functions/verifyErrors';\nimport {validate} from \"./help\";\nimport {exception} from './verifyErrors'\n\n/**\n *\n * Response messages due to validation failure\n */\nconst messageArgument: AR.MessageArgument = {\n    validation: () => ({\n        message: `validation_custom`\n    }),\n    required: () => ({\n        message: \"required_field\"\n    }),\n    min: (props) => ({\n        message: \"minimum_characters\",\n        value: props.validValue\n    }),\n    max: (props) => ({\n        message: \"maximum_characters\",\n        value: props.validValue\n    }),\n    strict: (props) => ({\n        message: \"{key}_expected_data_type_{type}\"\n            .replace('{key}', props.key)\n            .replace('{type}', props.type)\n            .toLowerCase()\n    })\n}\n\nfunction ejectMessage(key: string, props: any): AR.MessageArgumentResponse | string {\n\n    if (props.message && key) {\n        if (typeof props.message == 'string') return props.message;\n        if (props.message[key]) return props.message;\n    }\n\n    switch (key) {\n        case 'validation': return messageArgument.validation();\n        case 'required': return messageArgument.required();\n        case 'min': return messageArgument.min(props);\n        case 'max': return messageArgument.max(props);\n        case 'strict': return messageArgument.strict(props);\n        default:\n            throw 'non-specific validation function: undefined response message'\n    }\n}\n\n/**\n *  list of validation functions\n *\n * @param funcArguments -\n */\nconst funcArguments: AR.funcArguments = {\n    /**\n     *  * custom validation, for the data type specified in the argument\n     *\n     * @example\n     * ```json\n     * {\n     *    email: {\n     *    type: Sandwich.String, validation: (value: string) => typeof value == 'string'\n     *  }\n     * }\n     * ```\n     * @param validValue -\n     * @param value -\n     */\n    validation: ({validValue, value}) => validValue(value),\n    /**\n     * Validate value max\n     *\n     * @param type -\n     * @param validValue -\n     * @param value -\n     */\n    max: ({type, validValue, value}) => {\n        if (typeof value === 'number'){\n            return (value ?? 0) <= (validValue ?? 0);\n        } else {\n            const len = (type?.length ?? 0) ?? (type?.toString()?.length ?? 0);\n            return len <= (validValue ?? 0);\n        }\n\n    },\n    /**\n     * Validate value min\n     *\n     * @param type -\n     * @param validValue -\n     * @param value -\n     */\n    min: ({type, validValue, value}) => {\n        if (typeof value === 'number'){\n            return (validValue ?? 0) >= (validValue ?? 0);\n        } else {\n            const len = (type?.length ?? 0) ?? (type?.toString()?.length ?? 0);\n            return len >= (validValue ?? 0);\n        }\n    },\n    /**\n     * validate value required\n     *\n     * @param validValue -\n     * @param value -\n     */\n    required: ({validValue, value}) => validValue ? (!!value || value === 0) : true,\n    /**\n     * Validate value type\n     *\n     * @param value -\n     * @param func -\n     * @param scheme -\n     */\n     type: (value, func, scheme) => {\n        const list_type = ['String', 'Number', 'Object'];\n\n        switch (func.name) {\n            case 'Array': return func.from(value);\n            default:\n                if (list_type.includes(func.name)){\n                    return new func(value)\n                }\n                return func(value, scheme);\n        }\n    },\n    /**\n     * Strictly validates the value of a data type\n     *\n     * @param strict - true to validate or false not to validate strict mode\n     * @param type - Array\n     * @param key - data (occupation)\n     * @param value - `Developer`\n     */\n    validStrict: (strict, type, key, value) => {\n        const valid = validate.get(type);\n\n        if (strict && valid) {\n            !valid(value) ? exception({\n                message: \"args_validation_errors\",\n                errors: [{\n                    [key]: [messageArgument.strict({key, type})]\n                }]\n            }, 400): true\n        }\n    }\n}\n\n/**\n *\n * @param key -\n * @param props -\n */\nfunction validArguments(key: string, props: any): boolean {\n    switch (key) {\n        case 'required': return funcArguments.required(props);\n        case 'min': return funcArguments.min(props);\n        case 'max': return funcArguments.max(props);\n        case 'validation': return funcArguments.validation(props);\n        default:\n            throw 'non-specific validation function'\n    }\n}\n\n/**\n * Validate a data type\n *\n * @param value - value to validate \"Developer\"\n * @param key - value key (occupation)\n * @param scheme - scheme validation\n * ```json\n * {type: String}\n * ```\n */\nasync function validType ({value, key, scheme}: AR.compareProps): Promise<any> {\n    const type: any = scheme['type'];\n    const strict = scheme['strict'];\n    const required = scheme['required'];\n\n    if (type) {\n        const name = type.name;\n        required && value ? funcArguments.validStrict(strict, name, key, value): null;\n        if (value === null || value === undefined) return value;\n        return funcArguments.type(value, type, scheme);\n    } else {\n        exception({message: `${key} => ${value} no data type`}, 500);\n    }\n}\n\n/**\n * Validate a schema against a value\n *\n * @param props - data\n * @param type - data type to validate example String\n * @param validValue - value of validation\n * @param keyValid - key main\n */\nfunction validData(\n    props: AR.compareProps, type: any, validValue: any, keyValid: keyof AR.MessageArgument\n): Promise<AR.MessageArgumentResponse | boolean> {\n    return new Promise((resolve) => {\n\n        const {value, scheme, message, key: keyMain} = props;\n\n        if(!validArguments(keyValid,{validValue, value, type, scheme})) {\n            resolve(ejectMessage(keyValid, {validValue, value, type, keyValid, keyMain, message}));\n        }\n\n        resolve(false);\n    })\n}\n\n/**\n * Validate a schema against a value\n *\n * @param props - data\n * @param type - data type to validate example String\n */\nasync function validExtractArgument (\n    props: AR.compareProps, type: any\n): Promise<(AR.MessageArgumentResponse | boolean)[]> {\n    const validResponse = [];\n    const {scheme} = props;\n\n    /**\n     *\n     */\n    if(scheme['required']) {\n        const resp = await validData(props, type, scheme['required'], 'required')\n        if(resp) validResponse.push(resp);\n    }\n\n    /**\n     *\n     */\n    if(scheme['min']){\n        const resp = await validData(props, type, scheme['min'], 'min');\n        if(resp) validResponse.push(resp);\n    }\n\n    /**\n     *\n     */\n    if(scheme['max']) {\n        const resp = await validData(props, type, scheme['max'], 'max');\n        if(resp) validResponse.push(resp);\n    }\n\n    /**\n     *\n     */\n    if(scheme['validation']) {\n        const resp =await validData(props, type, scheme['validation'], 'validation')\n        if(resp) validResponse.push(resp)\n    }\n\n    return validResponse;\n}\n\n/**\n * validate Message\n *\n * @param errors -\n */\nasync function validRespArgument (errors: (AR.MessageArgumentResponse | boolean)[]): Promise<boolean> {\n    return !errors.length;\n}\n\n/**\n * Validate an argument schema\n *\n * @param props - data\n *\n * @example\n * ```json\n * {\n *     value: \"example@sandwich.com\"\n *     key: \"email\"\n *     scheme: {type: Sandwich.String, strict: true}\n * }\n * ```\n */\nasync function validArgument (props: AR.compareProps): Promise<AR.validArgumentResp> {\n\n    const type =  await validType(props);\n    const errors = await validExtractArgument(props, type);\n    const success = await validRespArgument(errors);\n\n    return {errors: errors, success, value: type}\n}\n\n/**\n * Extract the defined value from the req or in the schema\n * (any value passed by req will be replaced by the value is defined in the schema)\n *\n * @param reqBody - data body\n * @param scheme -\n * @param key - field key to validate\n */\nfunction getValue(reqBody: { [index: string | number]: any }, scheme: VA.scheme, key: string | number): any {\n    const definedValue = scheme['value'] ?? reqBody[key];\n    return definedValue instanceof Function ? definedValue() : definedValue;\n}\n\n/**\n * This function validates all body data specified in the arguments\n *\n * @param valueOf - true stops returning the data to its primitive value of its instance\n * @param reqBody - request body\n * ```json\n * {email: \"example@sandwich.com\"}\n * ```\n * @param schemes - schemes of validation `{ email: {type: Sandwich.String, strict: true} }`\n */\nexport async function argument(\n    valueOf: boolean, reqBody: object, schemes?: VA.schemes\n): Promise<AR.argumentProps> {\n    const resp = {};\n    const body = {};\n    const errors: VE.ErrorStatus[] = []\n\n    if(!schemes) exception({message: `schemes is ${schemes}`}, 500)\n\n    for (const key in schemes) {\n        const scheme = schemes[key] ?? null;\n        if(scheme) {\n\n            const validated = await validArgument({\n                value: getValue(reqBody, scheme, key),\n                key: key,\n                message: scheme['message'] ?? null,\n                scheme: scheme\n            });\n\n            Object.defineProperty(resp, key, {\n                enumerable: true,\n                value: validated\n            });\n\n            Object.defineProperty(body, key, {\n                enumerable: true,\n                value: valueOf || !validated.value ? validated.value : validated.value.valueOf()\n            });\n\n            if (validated.errors.length) {\n                errors.push({[key]: validated.errors})\n            }\n\n        }\n    }\n\n    return {\n        argument: resp,\n        body,\n        errors\n    };\n}\n","import {TypeValid} from \"../functions/validator\";\n\n/**\n * Types of validations\n */\nclass Types implements TypeValid {\n    static String = String\n    static Number = Number\n    static Array = Array\n    static Boolean = Boolean\n    static Object = Object\n    String = String\n    Number = Number\n    Array = Array\n    Boolean = Boolean\n    Object = Object\n}\n\nexport default Types;","import {argument} from \"./argument\";\nimport {verifyErrors} from \"./verifyErrors\";\nimport Types from \"./type\";\nimport {\n    ParserSchemeFunction,\n    HandlerParserSchemes,\n    ValidatorsClass,\n    valuesArgs,\n    schemes,\n    valueOf\n} from \"../functions/validator\";\n\n/**\n * Analyze the values provided according to your schema.\n *\n * @param valueOf - Determines how validated arguments and parameters are extracted.\n * @param schemes - schemes\n * ```json\n * {\n *     email: {type: Sandwich.String, required: true, strict: true},\n *     password: {type: Sandwich.String, required: true, strict: true, min: 8}\n * }\n * ```\n * @param values - data body request.\n * @returns HandlerParserSchemes\n */\nexport const parserSchemes: HandlerParserSchemes = async (\n    valueOf, schemes, values\n) => {\n    const\n        /**\n         *  validate data\n         *\n         * @param result_argument - result argument\n         */\n        result_argument = await argument(valueOf ?? true, values ?? {}, schemes),\n\n        /**\n         * check for errors in arguments\n         *\n         * @param responseError - bug check response\n         */\n        responseError = await verifyErrors(result_argument.errors);\n\n    return {\n        schemes: result_argument.argument,\n        args: result_argument.body,\n        errors: responseError.errors,\n        message: responseError.message\n    }\n}\n\n\n/**\n * A Validators class, with functions that allow rigorously validating\n * data, according to a specific pattern (a schema).\n *\n * @remarks\n * A schema determines the validation pattern of a value, and if it\n * does not meet the conditions of the pattern, an exception is\n * thrown with the return of an array of the errors found.\n *\n * @beta\n */\nexport class Lettuce extends Types implements ValidatorsClass {\n\n    /**\n     * values to be validated\n     * @defaultValue undefined\n     */\n    values: valuesArgs = undefined;\n\n    /**\n     * Object type property. List of validation schemes.\n     * @defaultValue object\n     */\n    schemes: schemes;\n\n    /**\n     * Boolean type property. Determines how validated arguments\n     * and parameters are extracted.\n     * @defaultValue true\n     */\n    valueOf: valueOf = true;\n\n    /**\n     * Creates an instance of Sandwiches.\n     */\n    constructor(schemes?: schemes) {\n        super();\n        this.schemes = schemes ?? null;\n    }\n\n    /**\n     * parse and validate request body data\n     *\n     * @param values - Data subject to validation\n     * @returns ParserSchemesResponse\n     */\n    parserSchemes(values?: valuesArgs): ParserSchemeFunction\n    {\n        return parserSchemes(\n            this.valueOf, this.schemes, this.values ?? values\n        )\n    }\n\n    /**\n     * Reset data:\n     * ```ts\n     *  this.valueOf = true;\n     *  this.schemes = {};\n     *  this.values = undefined;\n     * ```\n     */\n    reset() {\n        this.valueOf = true;\n        this.schemes = null;\n        this.values = undefined;\n    }\n}\n\nexport default Lettuce;\n","import {\n    ParserSchemeFunction,\n    ParserSchemesClass,\n    valuesArgs,\n    schemes,\n    scheme,\n    FuncResolvePromiseScheme,\n    resolvePromiseScheme\n} from \"../functions/validator\";\nimport Lettuce from './lettuce'\n\nconst validator = new Lettuce();\n\n/**\n * addSchemes add schemes\n *\n * @privateRemarks\n * addSchemes function serving the ParserLettuce class for\n * adding validation schemes\n *\n * @param schemes - Validation schemes\n */\nconst addSchemes = (schemes: unknown) => {\n    validator.schemes = Object.assign(validator.schemes ?? {}, schemes);\n}\n\n/**\n * handle the function addScheme, which belongs to the class ParserSchemes\n *\n * @param callBack - receives as argument the resolution function of\n * new Promise, and the value processed in the callback is passed to\n * it, this value is the validation scheme of an element\n */\nconst handlerAddScheme = (callBack: FuncResolvePromiseScheme) => {\n    new Promise((resolve) => {\n        callBack(resolve);\n    }).then((schemes: unknown) => {\n        addSchemes(schemes);\n    });\n}\n\n/**\n * Processes and assigns to validator.schemes the validation\n * schemes declared as property in a class.\n *\n * @param schemesEntries - Matrix of schemes\n *\n * @example\n * Matrix schemes:\n * ```json\n * [\n *  ['name' {type: Type.String, required: true, strict: true}],\n *  ['email' {type: Type.String, required: true, strict: true}]\n * ]\n * ```\n */\nconst addPropertySchemesValidator = <T>(schemesEntries: [keyof T, T[keyof T]][]): Promise<void> => {\n    return new Promise((resolve) => {\n        resolve(Object.fromEntries(schemesEntries));\n    }).then((schemeData) => {\n        validator.schemes = Object.assign(validator.schemes, schemeData);\n    })\n}\n\nexport class ParserLettuce implements ParserSchemesClass {\n\n    /**\n     * instance ParserLettuce\n     */\n    constructor(valueOf?: boolean) {\n        validator.reset();\n        validator.valueOf = valueOf ?? true;\n    }\n\n    /**\n     * Activating the schema validation functions\n     */\n    parserSchemes(values?: valuesArgs): ParserSchemeFunction {\n        return addPropertySchemesValidator(Object.entries(this))\n            .then(()=> validator.parserSchemes(values));\n    }\n\n    /**\n     * add schemes\n     *\n     * @param schemes - Validations schemes\n     */\n    addSchemes(schemes: schemes) {\n        addSchemes(schemes);\n    }\n\n    /**\n     * The addScheme property must be represented in the child class as a function\n     * within this function the schemas are loaded for the validation of the arguments\n     *\n     * @example\n     *```ts\n     * addScheme({type: Sandwich.String, required: true, strict: true}, ['email'])\n     *```\n     * @param scheme - Validations scheme\n     * @param arg - Name of the argument to validate, can be a string or an array of strings.\n     *\n     * @example\n     * example param arg:\n     * ```ts\n     * 'password' or ['password', 'passwordConfirm']\n     * ```\n     *\n     */\n    addScheme(scheme: scheme, arg: string | string[]) {\n        handlerAddScheme((add: resolvePromiseScheme): void => {\n            if(typeof arg == 'string') {\n                add({\n                    [arg]: scheme\n                });\n            } else {\n                let sh = {}\n                for (let i = 1; i <= arg.length; i++) {\n                    sh = {\n                        [arg[i -1]]: scheme,\n                        ...sh\n                    }\n                    if(i == arg.length) add(sh);\n                }\n            }\n        });\n    }\n}\n","import Lettuce from './lettuce';\nimport Types from \"./type\";\nimport {ParserLettuce} from './parserLettuce';\n\nexport {\n    ParserLettuce,\n    Types\n}\n\nexport default  Lettuce;"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","this","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","validate","Map","set","elm","Array","isArray","toString","exception","response","code","error","errors","responseServerError","verifyErrors","message","length","messageArgument","props","replace","type","toLowerCase","funcArguments","func","scheme","name","from","includes","validType","strict","required","valid","validData","validValue","keyValid","Promise","resolve","keyMain","validArguments","ejectMessage","validExtractArgument","validResponse","resp","push","validRespArgument","validArgument","success","getValue","reqBody","definedValue","argument","valueOf","schemes","body","validated","String","Number","Boolean","values","undefined","parserSchemes","result_argument","responseError","args","reset","validator","addSchemes","assign","schemesEntries","entries","fromEntries","then","schemeData","addScheme","arg","callBack","add","sh","i"],"sourceRoot":""}