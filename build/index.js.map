{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@amateury/lettuce/./src/help.ts","webpack://@amateury/lettuce/./src/lettuce.ts","webpack://@amateury/lettuce/./src/parser.ts","webpack://@amateury/lettuce/webpack/bootstrap","webpack://@amateury/lettuce/webpack/runtime/define property getters","webpack://@amateury/lettuce/webpack/runtime/global","webpack://@amateury/lettuce/webpack/runtime/hasOwnProperty shorthand","webpack://@amateury/lettuce/webpack/runtime/make namespace object","webpack://@amateury/lettuce/./src/index.ts"],"sourcesContent":["export type TIsValidate = (elm: any) => boolean;\n\n/**\n * Identify if it is running in a nodejs\n */\nexport const isNode: () => boolean = () =>\n  typeof global !== \"undefined\" &&\n  {}.toString.call(global) === \"[object Object]\";\n\n/**\n * Identify if it is running in a browser\n */\nexport const isBrowser: () => boolean = () => !isNode();\n\n/**\n * validate if it is an array\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isArray(elm: any): boolean {\n  return Array.isArray(elm);\n}\n\n/**\n * validate if it is an objet\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isObject(elm: any): boolean {\n  return elm instanceof Object;\n}\n\n/**\n * validate if it is an string\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isString(elm: any): boolean {\n  return typeof elm === \"string\";\n}\n\n/**\n * validate if it is a number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isNumber(elm: any): boolean {\n  return typeof elm === \"number\";\n}\n\n/**\n * validate if it is a number\n *\n * @param elm - element validation\n * @returns boolean\n */\nexport function isBoolean(elm: any): boolean {\n  return typeof elm === \"boolean\";\n}\n\n/**\n * Functions validations (isArray, isString)\n *\n */\nexport const validate = new Map<string, TIsValidate>();\nvalidate.set(\"Array\", isArray);\nvalidate.set(\"String\", isString);\nvalidate.set(\"Number\", isNumber);\nvalidate.set(\"Object\", isObject);\nvalidate.set(\"Browser\", isBrowser);\nvalidate.set(\"Node\", isNode);\nvalidate.set(\"Boolean\", isBoolean);\n","import * as parser from \"./parser\";\n\ninterface ILettuce {\n  readonly schemes: parser.IScheme[];\n  values?: parser.TValues;\n}\n\nclass Lettuce implements ILettuce {\n  /**\n   * Object type property. List of validation schemes.\n   * @defaultValue object\n   */\n  schemes: parser.IScheme[];\n\n  /**\n   * values to be validated\n   * @defaultValue null\n   */\n  values?: parser.TValues;\n\n  /**\n   * Creates an instance of Lettuce.\n   */\n  constructor(schemas: parser.IScheme[] | null, values?: parser.TValues) {\n    this.schemes = schemas ?? [];\n    if (values) this.values = values;\n  }\n\n  async parser(values?: parser.TValues): Promise<any> {\n    if (values) this.values = values;\n    return parser.parserScheme(this.schemes, this.values);\n  }\n}\n\nexport default Lettuce;\n","import { validate, isBoolean } from \"./help\";\n\ntype TTarget = string | number;\ntype TRegex = RegExp;\ntype TType = any;\n\nexport interface IScheme {\n  target: TTarget;\n  type: TType;\n  required?: boolean;\n  min?: number;\n  max?: number;\n  value?: ((value: any) => any) | any;\n  strict?: boolean;\n  regex?: TRegex;\n  message?: any;\n}\n\nexport type TValue = any;\n\n/**\n * Values\n */\nexport type TValues = {\n  [index: TTarget]: TValue;\n};\n\nexport type TErrorVal = string;\n\nexport type TErrors = {\n  error: TErrorVal[];\n  target: TTarget;\n  value: any | any[];\n};\n\n/**\n * Run a bug\n * @param e - Error\n */\nconst error = (e: any) => {\n  throw e;\n};\n\n/**\n * Validate is required\n * @param required - Value required (boolean)\n * @param val - Value of validation\n */\nconst isRequired = async (\n  required: boolean | undefined,\n  val: TValue\n): Promise<void> => {\n  if (required && !val && !isBoolean(val)) error(\"required\");\n};\n\n/**\n * In this function, the custom data type is validated through\n * the static method __validate__.\n * @param val - Value of validation\n * @param type - Data type\n */\nconst customValidateValue = async (val: TValue, type: TType) => {\n  try {\n    const valid = await type.__validate__(val);\n    if (!valid) error(\"type\");\n  } catch (e) {\n    console.error(e);\n    if (e !== \"type\") error(\"No validation custom format found\");\n    error(e);\n  }\n};\n/**\n * Validate data type\n * @param scheme - Type to validation\n * @param val - Value of validation\n * @param type - Data type\n * @param strict - It is a boolean to know if the data will be\n * strictly validated\n */\nconst validateValueType = async (\n  scheme: IScheme,\n  val: TValue,\n  type: TType,\n  strict: boolean | undefined\n): Promise<TValue> => {\n  if (strict) {\n    const validateStrict = validate.get(type.name);\n    if (validateStrict) {\n      if (!validateStrict(val)) error(\"type\");\n    } else {\n      await customValidateValue(val, type);\n    }\n  }\n\n  let formatVal: any;\n  if (type.name === \"Array\") {\n    formatVal = val ? type.from(val) : val;\n  } else {\n    formatVal = val ? type(val) : val;\n  }\n  return val\n    ? await complementaryValidation(scheme, formatVal, type.name)\n    : val;\n};\n\n/**\n * Validate data type\n * @param scheme - Type to validation\n * @param val - Value of validation\n * @param type - Data type\n */\nconst valuePick = async (scheme: IScheme, val: TValue, type: TType) => {\n  const keys = Object.keys(type);\n  let len = keys.length + 1;\n  while (--len) {\n    const typeOrPick = type[keys[keys.length - len]];\n    if (typeOrPick instanceof Function) {\n      const nameFuncType = typeOrPick.name;\n      try {\n        if (nameFuncType.toString().toLocaleLowerCase() === typeof val)\n          return await validateValueType(scheme, val, typeOrPick, undefined);\n        // eslint-disable-next-line no-empty\n      } finally {\n      }\n    } else {\n      if (val === typeOrPick) return val;\n    }\n    if (len === 1) error(\"pick\");\n  }\n};\n\n/**\n * Formats the target value to the specified type\n * @param scheme - Type to validation\n * @param val - Value of validation\n */\nconst valueType = async (scheme: IScheme, val: TValue): Promise<TValue> => {\n  const type = scheme.type; // Type to validation\n  const strict = scheme.strict; //Validation strict\n  if (typeof type === \"object\") return await valuePick(scheme, val, type);\n  return await validateValueType(scheme, val, type, strict);\n};\n\n/**\n * Evaluate minimum value\n * @param val - Value of validation\n * @param min - Value of minimum (number)\n * @param typeName - Name function type\n */\nconst min = async (val: TValue, min: number, typeName: string) => {\n  let validMin = null;\n  if (val.length) {\n    validMin = val.length >= min;\n  } else if (typeName === \"Number\" || typeName === \"BigInt\") {\n    validMin = val >= min;\n  }\n  if (validMin !== null && !validMin) error(\"min\");\n  if (!validMin)\n    error(\n      `it is not possible to evaluate the minimum value for the type: ${typeof val}`\n    );\n\n  return validMin;\n};\n\n/**\n * Evaluate maximum value\n * @param val - Value of validation\n * @param max - Value of maximum (number)\n * @param typeName - Name function type\n */\nconst max = async (val: TValue, max: number, typeName: string) => {\n  let validMin = null;\n\n  if (val.length) {\n    validMin = val.length <= max;\n  } else if (typeName === \"Number\" || typeName === \"BigInt\") {\n    validMin = val <= max;\n  }\n  if (validMin !== null && !validMin) error(\"max\");\n  if (!validMin)\n    error(\n      `it is not possible to evaluate the maximum value for the type:: ${typeof val}`\n    );\n\n  return validMin;\n};\n\nconst regexValid = async (val: TValue, reg: TRegex) => {\n  if (!reg.test(val)) error(\"regex\");\n};\n\n/**\n * Complementary validation: minimum value, maximum value\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n * @param typeName - Name function type\n */\nasync function complementaryValidation(\n  scheme: IScheme,\n  val: TValue,\n  typeName: string\n): Promise<TValue> {\n  if (scheme.min) await min(val, scheme.min, typeName);\n  if (scheme.max) await max(val, scheme.max, typeName);\n  if (scheme.regex) await regexValid(val, scheme.regex);\n\n  return val;\n}\n\n/**\n * Add the default value, set the value property, the value property can be a\n * function and will be interpreted as a callback\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n */\nconst valueDefault = async (scheme: IScheme, val: TValue): Promise<TValue> => {\n  if (scheme.value && scheme.value instanceof Function)\n    return await scheme.value(val);\n  if (scheme.value !== undefined && !val) return scheme.value;\n  return val;\n};\n\ntype TRValidScheme = [TErrorVal[], TValue];\n\n/**\n * Function that validates the value against the schema data\n * @param scheme - Scheme of validation\n * @param val - Value of validation\n */\nasync function validScheme(\n  scheme: IScheme,\n  val: TValue\n): Promise<TRValidScheme> {\n  const errors: TErrorVal[] = [];\n  const strict = scheme.strict;\n\n  await isRequired(scheme.required, val).catch((e: any) =>\n    strict ? error(e) : errors.push(e)\n  );\n\n  return await valueType(scheme, val)\n    .catch((e: any) => {\n      strict ? error(e) : errors.push(e);\n    })\n    .then((resp) => [errors, resp ?? val]);\n}\n\ntype TResolution = (value: [TTarget, TValue]) => void;\ntype TCallBackErr = (value: TErrors) => void;\n\n/**\n * Function that serves as a bridge between validScheme and parserScheme\n * @param resolution - callback that sets the resolved values\n * @param callBackErr - callback that sets the values with error\n * @param scheme - Scheme\n * @param val - Value of validation\n */\nasync function runValidation(\n  resolution: TResolution,\n  callBackErr: TCallBackErr,\n  scheme: IScheme,\n  val: any\n) {\n  await validScheme(scheme, val)\n    .then(([err, value]) => {\n      if (err.length) {\n        return callBackErr({\n          error: [...err],\n          target: scheme.target,\n          value: val,\n        });\n      }\n      resolution([scheme.target, value]);\n    })\n    .catch((e) => {\n      error([\n        {\n          error: [e],\n          target: scheme.target,\n          value: val,\n        },\n      ]);\n    });\n}\n\n/**\n * Analyze the values provided according to your schema.\n * @param schemes - Schemes\n * @example\n * Example of a schematic:\n *```json\n *[\n *  { target: \"email\", type: String, required: true, strict: true},\n *  { target: \"name\", type: String, required: true, strict: true, min: 8, max: 80},\n *  { target: \"password\", type: String, required: true, strict: true, min: 8},\n *]\n *```\n * @param values - Data to validate\n * @example\n * Example of a data to validate:\n * ```json\n * {\n *   email: \"lettuce@lettuce.com\",\n *   name: \"Lettuce\",\n *   password: \"sW6LT#Fh\",\n * }\n * ```\n */\nexport async function parserScheme(schemes: IScheme[], values: TValues = {}) {\n  let len = schemes.length + 1;\n\n  type TFun = {\n    _values: TValues;\n    values: TValues;\n    _errors: TErrors[];\n    resolution: TResolution;\n    callBackErr: TCallBackErr;\n  };\n\n  const fun: TFun = {\n    _values: {},\n    _errors: [],\n    get values(): TValues {\n      return this._values;\n    },\n    resolution([target, val]: [TTarget, TValue]): void {\n      if (val !== undefined)\n        Object.defineProperty(fun._values, target, {\n          enumerable: true,\n          value: val,\n        });\n    },\n    callBackErr(value: TErrors) {\n      fun._errors.push(value);\n    },\n  };\n\n  while (--len) {\n    const scheme = schemes[schemes.length - len];\n    const val = await valueDefault(scheme, values[scheme.target]);\n    await runValidation(fun.resolution, fun.callBackErr, scheme, val);\n  }\n  return fun._errors.length ? error(fun._errors) : fun.values;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export * from \"./parser\";\nimport Lettuce from \"./lettuce\";\n\nexport default Lettuce;\n"],"names":[],"sourceRoot":""}